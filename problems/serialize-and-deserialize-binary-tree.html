<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>297. Serialize and Deserialize Binary Tree - LeetCode 學習平台</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8fafc; line-height: 1.8; color: #334155; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); color: white; padding: 40px; border-radius: 16px; margin-bottom: 30px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .back-btn { display: inline-block; color: white; text-decoration: none; background: rgba(255,255,255,0.2); padding: 10px 20px; border-radius: 8px; margin-bottom: 20px; transition: all 0.3s; }
        .back-btn:hover { background: rgba(255,255,255,0.3); }
        .problem-title { font-size: 2.5em; font-weight: 800; margin-bottom: 15px; }
        .difficulty { display: inline-block; background: rgba(255,255,255,0.3); padding: 8px 20px; border-radius: 20px; font-weight: 600; font-size: 0.9em; }
        .content-section { background: white; padding: 40px; border-radius: 16px; margin-bottom: 25px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .section-title { font-size: 1.8em; color: #1e293b; margin-bottom: 25px; font-weight: 700; padding-bottom: 10px; border-bottom: 3px solid #dc2626; }
        .description { font-size: 1.1em; line-height: 1.9; color: #475569; margin-bottom: 20px; }
        .example-box { background: #fee2e2; border-left: 4px solid #dc2626; padding: 20px; border-radius: 8px; margin: 20px 0; }
        .example-title { font-weight: 700; color: #991b1b; margin-bottom: 10px; font-size: 1.1em; }
        .approach-box { background: #eff6ff; border-left: 4px solid #3b82f6; padding: 25px; border-radius: 8px; margin: 25px 0; }
        .approach-title { font-weight: 700; color: #1e40af; margin-bottom: 15px; font-size: 1.3em; }
        .complexity-box { background: #fef3c7; border-left: 4px solid #f59e0b; padding: 20px; border-radius: 8px; margin: 20px 0; }
        .complexity-item { margin: 10px 0; font-weight: 600; color: #92400e; }
        .language-tabs { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        .tab-btn { padding: 12px 28px; border: 2px solid #dc2626; background: white; color: #dc2626; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s; font-size: 1em; }
        .tab-btn:hover { background: #fee2e2; }
        .tab-btn.active { background: #dc2626; color: white; }
        .code-container { display: none; margin-top: 20px; }
        .code-container.active { display: block; }
        pre { background: #282c34 !important; padding: 25px !important; border-radius: 12px; overflow-x: auto; margin: 0; }
        code { font-family: 'Fira Code', 'Consolas', monospace; font-size: 0.95em; line-height: 1.6; }
        ol, ul { margin-left: 30px; margin-top: 15px; }
        li { margin: 12px 0; line-height: 1.8; }
        strong { color: #1e293b; font-weight: 700; }
        .visual-box { background: #f0f9ff; border: 2px solid #3b82f6; padding: 20px; border-radius: 8px; margin: 20px 0; }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .header { padding: 25px; }
            .problem-title { font-size: 1.8em; }
            .content-section { padding: 25px; }
            .tab-btn { padding: 10px 20px; font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="../index.html" class="back-btn">← 返回題目列表</a>
            <div class="problem-title">297. Serialize and Deserialize Binary Tree</div>
            <span class="difficulty">Hard</span>
        </div>

        <div class="content-section">
            <h2 class="section-title">題目描述</h2>
            <div class="description">
                <p>序列化是將一個數據結構或者物件轉換為連續的位元，以便它可以存儲到一個檔案或者記憶體中，同時也可以透過網路傳輸到另一個計算機環境，採取相反方式重構得到原數據。</p>
                <p style="margin-top: 15px;">請設計一個演算法來實現二元樹的序列化與反序列化。這裡不限定你的序列化/反序列化演算法執行邏輯，你只需要保證一個二元樹可以被序列化為一個字串並且將這個字串反序列化為原始的樹結構。</p>
                <p style="margin-top: 15px;"><strong>提示：</strong>輸入輸出格式與 LeetCode 目前使用的方式一致，詳情請參閱 LeetCode 序列化二元樹的格式。你並非必須採取這種方式，你也可以採用其他的方法解決這個問題。</p>
            </div>

            <div class="example-box">
                <div class="example-title">範例 1:</div>
                <pre><code>輸入: root = [1,2,3,null,null,4,5]
輸出: [1,2,3,null,null,4,5]</code></pre>
                <div style="margin-top: 10px; text-align: center;">
                    <svg width="280" height="180" style="background: white; border-radius: 8px; padding: 10px;">
                        <circle cx="140" cy="30" r="20" fill="#93c5fd" stroke="#3b82f6" stroke-width="2"/>
                        <text x="140" y="37" font-size="16" text-anchor="middle" font-weight="bold">1</text>
                        
                        <line x1="125" y1="45" x2="75" y2="75" stroke="#64748b" stroke-width="2"/>
                        <circle cx="70" cy="90" r="20" fill="#93c5fd" stroke="#3b82f6" stroke-width="2"/>
                        <text x="70" y="97" font-size="16" text-anchor="middle" font-weight="bold">2</text>
                        
                        <line x1="155" y1="45" x2="205" y2="75" stroke="#64748b" stroke-width="2"/>
                        <circle cx="210" cy="90" r="20" fill="#93c5fd" stroke="#3b82f6" stroke-width="2"/>
                        <text x="210" y="97" font-size="16" text-anchor="middle" font-weight="bold">3</text>
                        
                        <line x1="195" y1="105" x2="165" y2="135" stroke="#64748b" stroke-width="2"/>
                        <circle cx="160" cy="150" r="20" fill="#93c5fd" stroke="#3b82f6" stroke-width="2"/>
                        <text x="160" y="157" font-size="16" text-anchor="middle" font-weight="bold">4</text>
                        
                        <line x1="225" y1="105" x2="255" y2="135" stroke="#64748b" stroke-width="2"/>
                        <circle cx="260" cy="150" r="20" fill="#93c5fd" stroke="#3b82f6" stroke-width="2"/>
                        <text x="260" y="157" font-size="16" text-anchor="middle" font-weight="bold">5</text>
                    </svg>
                </div>
            </div>

            <div class="example-box">
                <div class="example-title">範例 2:</div>
                <pre><code>輸入: root = []
輸出: []</code></pre>
            </div>

            <div class="example-box">
                <div class="example-title">限制條件:</div>
                <pre><code>樹中節點數目在範圍 [0, 10^4] 內
-1000 <= Node.val <= 1000</code></pre>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">解題思路</h2>
            
            <div class="approach-box">
                <div class="approach-title">核心觀察</div>
                <p>這是一個經典的<strong>樹的遍歷與重構</strong>問題：</p>
                <ul>
                    <li>需要將樹結構轉換為字串（序列化）</li>
                    <li>需要從字串恢復樹結構（反序列化）</li>
                    <li>關鍵：選擇合適的遍歷順序和標記空節點</li>
                </ul>
                <p style="margin-top: 15px; color: #dc2626; font-weight: 600;">
                    多種解法：前序遍歷（DFS）、層序遍歷（BFS）
                </p>
            </div>
            
            <div class="approach-box">
                <div class="approach-title">方法一：前序遍歷 DFS（推薦）⭐⭐⭐</div>
                <p>使用前序遍歷（根-左-右）進行序列化和反序列化。</p>
                
                <p style="margin-top: 15px;"><strong>核心思想：</strong></p>
                <ul>
                    <li>前序遍歷：根節點 → 左子樹 → 右子樹</li>
                    <li>使用特殊符號（如 "null"）標記空節點</li>
                    <li>使用分隔符（如 ","）分隔節點值</li>
                </ul>
                
                <p style="margin-top: 15px;"><strong>序列化步驟：</strong></p>
                <ol>
                    <li>如果節點為空，添加 "null" 標記</li>
                    <li>添加當前節點值</li>
                    <li>遞迴序列化左子樹</li>
                    <li>遞迴序列化右子樹</li>
                </ol>
                
                <p style="margin-top: 15px;"><strong>反序列化步驟：</strong></p>
                <ol>
                    <li>將字串按分隔符分割成列表</li>
                    <li>使用指標或隊列依次讀取值</li>
                    <li>遇到 "null" 返回 None</li>
                    <li>創建節點，遞迴構建左右子樹</li>
                </ol>
                
                <div class="visual-box">
                    <p><strong>視覺化範例：</strong></p>
                    <pre style="background: white; padding: 15px; border-radius: 5px; margin-top: 10px;"><code>原始樹:
        1
       / \
      2   3
         / \
        4   5

前序遍歷序列化:
訪問順序: 1 → 2 → null → null → 3 → 4 → null → null → 5 → null → null
序列化結果: "1,2,null,null,3,4,null,null,5,null,null"

反序列化過程:
data = [1, 2, null, null, 3, 4, null, null, 5, null, null]
index = 0

1. 讀取 1，創建根節點
2. 遞迴左子樹：
   - 讀取 2，創建節點
   - 遞迴左：讀取 null，返回
   - 遞迴右：讀取 null，返回
3. 遞迴右子樹：
   - 讀取 3，創建節點
   - 遞迴左：
     * 讀取 4，創建節點
     * 遞迴左：讀取 null
     * 遞迴右：讀取 null
   - 遞迴右：
     * 讀取 5，創建節點
     * 遞迴左：讀取 null
     * 遞迴右：讀取 null</code></pre>
                </div>
            </div>

            <div class="approach-box">
                <div class="approach-title">方法二：層序遍歷 BFS⭐⭐</div>
                <p>使用 BFS（廣度優先搜尋）逐層序列化。</p>
                
                <p style="margin-top: 15px;"><strong>優點：</strong></p>
                <ul>
                    <li>序列化結果更直觀（符合 LeetCode 格式）</li>
                    <li>適合可視化</li>
                </ul>
                
                <p style="margin-top: 15px;"><strong>缺點：</strong></p>
                <ul>
                    <li>需要使用隊列</li>
                    <li>空間複雜度稍高</li>
                </ul>
                
                <div class="visual-box">
                    <p><strong>BFS 序列化範例：</strong></p>
                    <pre style="background: white; padding: 15px; border-radius: 5px; margin-top: 10px;"><code>        1
       / \
      2   3
         / \
        4   5

層序遍歷:
第1層: 1
第2層: 2, 3
第3層: null, null, 4, 5
第4層: null, null, null, null

序列化結果: "1,2,3,null,null,4,5"
（可以省略末尾的 null）</code></pre>
                </div>
            </div>

            <div class="approach-box">
                <div class="approach-title">設計考量</div>
                <ul style="margin-top: 10px;">
                    <li><strong>空節點標記：</strong>使用 "null" 或 "#" 或其他符號</li>
                    <li><strong>分隔符：</strong>使用 "," 或空格或其他字符</li>
                    <li><strong>數字範圍：</strong>考慮負數、多位數</li>
                    <li><strong>編碼格式：</strong>確保可逆性</li>
                </ul>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">程式碼實現</h2>
            
            <div class="language-tabs">
                <button class="tab-btn active" onclick="showLanguage('python')">Python</button>
                <button class="tab-btn" onclick="showLanguage('cpp')">C++</button>
                <button class="tab-btn" onclick="showLanguage('java')">Java</button>
            </div>

            <div id="python" class="code-container active">
                <pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

from collections import deque

class Codec:
    """
    方法一：前序遍歷 DFS
    時間複雜度: O(n)
    空間複雜度: O(n)
    """
    
    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        def dfs(node):
            if not node:
                return "null"
            # 前序遍歷：根 → 左 → 右
            return str(node.val) + "," + dfs(node.left) + "," + dfs(node.right)
        
        return dfs(root)
    
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        def dfs():
            val = next(vals)
            if val == "null":
                return None
            # 創建節點並遞迴構建左右子樹
            node = TreeNode(int(val))
            node.left = dfs()
            node.right = dfs()
            return node
        
        vals = iter(data.split(","))
        return dfs()


class Codec2:
    """
    方法二：層序遍歷 BFS
    時間複雜度: O(n)
    空間複雜度: O(n)
    """
    
    def serialize(self, root):
        if not root:
            return ""
        
        result = []
        queue = deque([root])
        
        while queue:
            node = queue.popleft()
            if node:
                result.append(str(node.val))
                queue.append(node.left)
                queue.append(node.right)
            else:
                result.append("null")
        
        # 移除末尾的 null
        while result and result[-1] == "null":
            result.pop()
        
        return ",".join(result)
    
    def deserialize(self, data):
        if not data:
            return None
        
        vals = data.split(",")
        root = TreeNode(int(vals[0]))
        queue = deque([root])
        i = 1
        
        while queue and i < len(vals):
            node = queue.popleft()
            
            # 處理左子節點
            if i < len(vals) and vals[i] != "null":
                node.left = TreeNode(int(vals[i]))
                queue.append(node.left)
            i += 1
            
            # 處理右子節點
            if i < len(vals) and vals[i] != "null":
                node.right = TreeNode(int(vals[i]))
                queue.append(node.right)
            i += 1
        
        return root


# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))</code></pre>
            </div>

            <div id="cpp" class="code-container">
                <pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;queue&gt;
using namespace std;

class Codec {
public:
    /**
     * 方法：前序遍歷 DFS
     * 時間複雜度: O(n)
     * 空間複雜度: O(n)
     */
    
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if (!root) return "null";
        return to_string(root->val) + "," + 
               serialize(root->left) + "," + 
               serialize(root->right);
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        stringstream ss(data);
        return deserializeHelper(ss);
    }
    
private:
    TreeNode* deserializeHelper(stringstream& ss) {
        string val;
        getline(ss, val, ',');
        
        if (val == "null") return nullptr;
        
        TreeNode* node = new TreeNode(stoi(val));
        node->left = deserializeHelper(ss);
        node->right = deserializeHelper(ss);
        return node;
    }
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));</code></pre>
            </div>

            <div id="java" class="code-container">
                <pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

import java.util.*;

public class Codec {
    /**
     * 方法：前序遍歷 DFS
     * 時間複雜度: O(n)
     * 空間複雜度: O(n)
     */
    
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if (root == null) return "null";
        return root.val + "," + serialize(root.left) + "," + serialize(root.right);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        Queue<String> queue = new LinkedList<>(Arrays.asList(data.split(",")));
        return deserializeHelper(queue);
    }
    
    private TreeNode deserializeHelper(Queue<String> queue) {
        String val = queue.poll();
        if (val.equals("null")) return null;
        
        TreeNode node = new TreeNode(Integer.parseInt(val));
        node.left = deserializeHelper(queue);
        node.right = deserializeHelper(queue);
        return node;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec ser = new Codec();
// Codec deser = new Codec();
// TreeNode ans = deser.deserialize(ser.serialize(root));</code></pre>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">複雜度分析</h2>
            <div class="complexity-box">
                <div class="complexity-item">時間複雜度: O(n)</div>
                <p style="color: #78716c; margin: 10px 0;">
                    序列化和反序列化都需要訪問每個節點一次。
                </p>
                
                <div class="complexity-item" style="margin-top: 20px;">空間複雜度: O(n)</div>
                <p style="color: #78716c; margin: 10px 0;">
                    存儲序列化字串和遞迴調用棧。
                </p>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">重點提示</h2>
            <div class="complexity-box">
                <ul>
                    <li><strong>為什麼前序遍歷最適合？</strong>
                        <ul style="margin-top: 8px;">
                            <li>根節點在最前，可以立即創建</li>
                            <li>然後依次構建左右子樹</li>
                            <li>符合遞迴構建的順序</li>
                        </ul>
                    </li>
                    <li><strong>為什麼需要標記空節點？</strong>
                        <ul style="margin-top: 8px;">
                            <li>確定樹的結構</li>
                            <li>知道何時停止遞迴</li>
                            <li>區分左右子樹</li>
                        </ul>
                    </li>
                    <li><strong>DFS vs BFS：</strong>
                        <ul style="margin-top: 8px;">
                            <li><strong>DFS（前序）：</strong>代碼簡潔，遞迴實現</li>
                            <li><strong>BFS（層序）：</strong>結果直觀，符合 LeetCode 格式</li>
                            <li>兩者都是 O(n) 時間和空間</li>
                        </ul>
                    </li>
                    <li><strong>字串格式設計：</strong>
                        <ul style="margin-top: 8px;">
                            <li>分隔符要明確（避免歧義）</li>
                            <li>空節點標記要統一</li>
                            <li>考慮負數的處理（"-" 不是分隔符）</li>
                        </ul>
                    </li>
                    <li><strong>Python 特殊技巧：</strong>
                        <ul style="margin-top: 8px;">
                            <li>使用 iter() 和 next() 處理字串列表</li>
                            <li>避免手動維護索引</li>
                            <li>代碼更簡潔</li>
                        </ul>
                    </li>
                    <li><strong>邊界情況：</strong>
                        <ul style="margin-top: 8px;">
                            <li>空樹 → ""</li>
                            <li>單節點 → "val,null,null"</li>
                            <li>負數節點</li>
                            <li>多位數</li>
                        </ul>
                    </li>
                    <li><strong>常見錯誤：</strong>
                        <ul style="margin-top: 8px;">
                            <li>忘記處理空節點</li>
                            <li>分隔符選擇不當（與節點值衝突）</li>
                            <li>索引越界</li>
                            <li>遞迴順序錯誤</li>
                        </ul>
                    </li>
                    <li><strong>面試技巧：</strong>
                        <ul style="margin-top: 8px;">
                            <li>先說明選擇的遍歷方式</li>
                            <li>解釋為什麼需要標記空節點</li>
                            <li>畫圖展示序列化和反序列化過程</li>
                            <li>可以提到 BFS 替代方案</li>
                        </ul>
                    </li>
                    <li><strong>與其他遍歷的比較：</strong>
                        <ul style="margin-top: 8px;">
                            <li><strong>中序：</strong>不能唯一確定樹結構</li>
                            <li><strong>後序：</strong>可以用，但根節點在最後，不太直觀</li>
                            <li><strong>前序：</strong>最佳選擇</li>
                        </ul>
                    </li>
                    <li><strong>延伸思考：</strong>
                        <ul style="margin-top: 8px;">
                            <li>如何壓縮序列化字串？（使用位元操作）</li>
                            <li>如何處理 N 叉樹？</li>
                            <li>如何實現增量序列化？</li>
                        </ul>
                    </li>
                    <li><strong>實際應用：</strong>
                        <ul style="margin-top: 8px;">
                            <li>數據持久化（存儲到數據庫/檔案）</li>
                            <li>網路傳輸（Client-Server）</li>
                            <li>緩存（Redis 等）</li>
                            <li>深拷貝樹結構</li>
                        </ul>
                    </li>
                    <li><strong>變形題：</strong>
                        <ul style="margin-top: 8px;">
                            <li>Serialize and Deserialize BST (#449)</li>
                            <li>Encode and Decode Strings (#271)</li>
                            <li>Serialize and Deserialize N-ary Tree (#428)</li>
                        </ul>
                    </li>
                    <li><strong>相似題目：</strong>Construct Binary Tree (105, 106)</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        hljs.highlightAll();
        
        function showLanguage(lang) {
            document.querySelectorAll('.code-container').forEach(container => {
                container.classList.remove('active');
            });
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(lang).classList.add('active');
            event.target.classList.add('active');
        }
    </script>
</body>
</html>