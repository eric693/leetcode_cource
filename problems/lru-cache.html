<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>146. LRU Cache - LeetCode 學習平台</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8fafc; line-height: 1.8; color: #334155; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; padding: 40px; border-radius: 16px; margin-bottom: 30px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .back-btn { display: inline-block; color: white; text-decoration: none; background: rgba(255,255,255,0.2); padding: 10px 20px; border-radius: 8px; margin-bottom: 20px; transition: all 0.3s; }
        .back-btn:hover { background: rgba(255,255,255,0.3); }
        .problem-title { font-size: 2.5em; font-weight: 800; margin-bottom: 15px; }
        .difficulty { display: inline-block; background: rgba(255,255,255,0.3); padding: 8px 20px; border-radius: 20px; font-weight: 600; font-size: 0.9em; }
        .content-section { background: white; padding: 40px; border-radius: 16px; margin-bottom: 25px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .section-title { font-size: 1.8em; color: #1e293b; margin-bottom: 25px; font-weight: 700; padding-bottom: 10px; border-bottom: 3px solid #ef4444; }
        .description { font-size: 1.1em; line-height: 1.9; color: #475569; margin-bottom: 20px; }
        .example-box { background: #fee2e2; border-left: 4px solid #ef4444; padding: 20px; border-radius: 8px; margin: 20px 0; }
        .example-title { font-weight: 700; color: #dc2626; margin-bottom: 10px; font-size: 1.1em; }
        .approach-box { background: #eff6ff; border-left: 4px solid #3b82f6; padding: 25px; border-radius: 8px; margin: 25px 0; }
        .approach-title { font-weight: 700; color: #1e40af; margin-bottom: 15px; font-size: 1.3em; }
        .complexity-box { background: #fef3c7; border-left: 4px solid #f59e0b; padding: 20px; border-radius: 8px; margin: 20px 0; }
        .complexity-item { margin: 10px 0; font-weight: 600; color: #92400e; }
        .language-tabs { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        .tab-btn { padding: 12px 28px; border: 2px solid #ef4444; background: white; color: #ef4444; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s; font-size: 1em; }
        .tab-btn:hover { background: #fee2e2; }
        .tab-btn.active { background: #ef4444; color: white; }
        .code-container { display: none; margin-top: 20px; }
        .code-container.active { display: block; }
        pre { background: #282c34 !important; padding: 25px !important; border-radius: 12px; overflow-x: auto; margin: 0; }
        code { font-family: 'Fira Code', 'Consolas', monospace; font-size: 0.95em; line-height: 1.6; }
        ol, ul { margin-left: 30px; margin-top: 15px; }
        li { margin: 12px 0; line-height: 1.8; }
        strong { color: #1e293b; font-weight: 700; }
        .visual-box { background: #f0f9ff; border: 2px solid #3b82f6; padding: 20px; border-radius: 8px; margin: 20px 0; }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .header { padding: 25px; }
            .problem-title { font-size: 1.8em; }
            .content-section { padding: 25px; }
            .tab-btn { padding: 10px 20px; font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="../index.html" class="back-btn">← 返回題目列表</a>
            <div class="problem-title">146. LRU Cache</div>
            <span class="difficulty">Hard</span>
        </div>

        <div class="content-section">
            <h2 class="section-title">題目描述</h2>
            <div class="description">
                <p>設計並實現一個 <strong>LRU (Least Recently Used，最近最少使用)</strong> 快取機制。它應該支持以下操作：獲取數據 <code>get</code> 和寫入數據 <code>put</code>。</p>
                
                <ul style="margin-left: 30px; margin-top: 15px;">
                    <li><code>get(key)</code> - 如果密鑰存在於快取中，則獲取密鑰的值（總是正數），否則返回 -1。</li>
                    <li><code>put(key, value)</code> - 如果密鑰不存在，則寫入數據。當快取達到其容量時，它應該在寫入新數據之前刪除最近最少使用的數據項。</li>
                </ul>
                
                <p style="margin-top: 15px;"><strong>進階：</strong>你能否在 <strong>O(1)</strong> 時間複雜度內完成這兩種操作？</p>
            </div>

            <div class="example-box">
                <div class="example-title">範例:</div>
                <pre><code>LRUCache cache = new LRUCache(2); // 容量為 2

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回 1
cache.put(3, 3);    // 該操作會使得密鑰 2 作廢
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 該操作會使得密鑰 1 作廢
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回 3
cache.get(4);       // 返回 4</code></pre>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">解題思路</h2>
            
            <div class="approach-box">
                <div class="approach-title">核心概念：HashMap + 雙向鏈表</div>
                <p><strong>為什麼需要兩種資料結構？</strong></p>
                <ul>
                    <li><strong>HashMap：</strong>實現 O(1) 的查找</li>
                    <li><strong>雙向鏈表：</strong>實現 O(1) 的插入、刪除、移動節點</li>
                </ul>
                
                <p style="margin-top: 15px;"><strong>LRU 策略：</strong></p>
                <ul>
                    <li>最近使用的數據放在鏈表頭部</li>
                    <li>最久未使用的數據放在鏈表尾部</li>
                    <li>容量滿時，刪除尾部節點</li>
                </ul>
            </div>

            <div class="approach-box">
                <div class="approach-title">方法：HashMap + 雙向鏈表（推薦）⭐</div>
                <p>使用哨兵節點（dummy head 和 dummy tail）簡化邊界處理。</p>
                
                <p style="margin-top: 15px;"><strong>資料結構設計：</strong></p>
                <pre style="background: #f0f9ff; padding: 15px; border-radius: 8px; margin-top: 10px;"><code>雙向鏈表節點:
class Node:
    key: int
    value: int
    prev: Node
    next: Node

LRU Cache:
    capacity: int           # 容量
    cache: HashMap          # key -> Node
    head: Node             # 哨兵頭節點
    tail: Node             # 哨兵尾節點</code></pre>
                
                <p style="margin-top: 15px;"><strong>核心操作：</strong></p>
                <ol>
                    <li><strong>get(key)：</strong>
                        <ul>
                            <li>在 HashMap 中查找節點</li>
                            <li>如果存在，將節點移到鏈表頭部（最近使用）</li>
                            <li>返回值</li>
                        </ul>
                    </li>
                    <li><strong>put(key, value)：</strong>
                        <ul>
                            <li>如果 key 存在，更新值並移到頭部</li>
                            <li>如果 key 不存在：
                                <ul>
                                    <li>創建新節點並加入頭部</li>
                                    <li>如果超過容量，刪除尾部節點</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ol>
                
                <div class="visual-box">
                    <p><strong>視覺化範例：capacity = 2</strong></p>
                    <pre style="background: white; padding: 15px; border-radius: 5px; margin-top: 10px;"><code>初始狀態:
head <-> tail
HashMap: {}

put(1, 1):
head <-> [1:1] <-> tail
HashMap: {1: Node(1,1)}

put(2, 2):
head <-> [2:2] <-> [1:1] <-> tail
HashMap: {1: Node(1,1), 2: Node(2,2)}

get(1):  // 訪問 1，移到頭部
head <-> [1:1] <-> [2:2] <-> tail
返回 1

put(3, 3):  // 容量滿，刪除最久未用的 2
head <-> [3:3] <-> [1:1] <-> tail
HashMap: {1: Node(1,1), 3: Node(3,3)}

get(2):  // 2 已被刪除
返回 -1</code></pre>
                </div>
            </div>

            <div class="approach-box">
                <div class="approach-title">輔助函數</div>
                <ul>
                    <li><strong>addToHead(node)：</strong>將節點加入鏈表頭部</li>
                    <li><strong>removeNode(node)：</strong>從鏈表中移除節點</li>
                    <li><strong>moveToHead(node)：</strong>將節點移到頭部（先刪除再加入）</li>
                    <li><strong>removeTail()：</strong>刪除並返回尾部節點</li>
                </ul>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">程式碼實現</h2>
            
            <div class="language-tabs">
                <button class="tab-btn active" onclick="showLanguage('python')">Python</button>
                <button class="tab-btn" onclick="showLanguage('cpp')">C++</button>
                <button class="tab-btn" onclick="showLanguage('java')">Java</button>
            </div>

            <div id="python" class="code-container active">
                <pre><code class="language-python">class Node:
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:
    """
    HashMap + 雙向鏈表
    時間複雜度: O(1) for get and put
    空間複雜度: O(capacity)
    """
    
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}  # key -> Node
        
        # 哨兵節點
        self.head = Node()
        self.tail = Node()
        self.head.next = self.tail
        self.tail.prev = self.head
    
    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        
        node = self.cache[key]
        # 移到頭部（標記為最近使用）
        self.moveToHead(node)
        return node.value
    
    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            # 更新現有節點
            node = self.cache[key]
            node.value = value
            self.moveToHead(node)
        else:
            # 創建新節點
            node = Node(key, value)
            self.cache[key] = node
            self.addToHead(node)
            
            # 檢查容量
            if len(self.cache) > self.capacity:
                # 刪除尾部節點
                removed = self.removeTail()
                del self.cache[removed.key]
    
    def addToHead(self, node: Node) -> None:
        """將節點加入頭部"""
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
    
    def removeNode(self, node: Node) -> None:
        """從鏈表中移除節點"""
        node.prev.next = node.next
        node.next.prev = node.prev
    
    def moveToHead(self, node: Node) -> None:
        """將節點移到頭部"""
        self.removeNode(node)
        self.addToHead(node)
    
    def removeTail(self) -> Node:
        """刪除並返回尾部節點"""
        node = self.tail.prev
        self.removeNode(node)
        return node</code></pre>
            </div>

            <div id="cpp" class="code-container">
                <pre><code class="language-cpp">#include &lt;unordered_map&gt;

struct Node {
    int key, value;
    Node *prev, *next;
    Node(int k = 0, int v = 0) : key(k), value(v), prev(nullptr), next(nullptr) {}
};

class LRUCache {
private:
    int capacity;
    unordered_map<int, Node*> cache;
    Node *head, *tail;
    
    void addToHead(Node* node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }
    
    void removeNode(Node* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }
    
    void moveToHead(Node* node) {
        removeNode(node);
        addToHead(node);
    }
    
    Node* removeTail() {
        Node* node = tail->prev;
        removeNode(node);
        return node;
    }

public:
    /**
     * HashMap + 雙向鏈表
     * 時間複雜度: O(1)
     * 空間複雜度: O(capacity)
     */
    LRUCache(int capacity) : capacity(capacity) {
        head = new Node();
        tail = new Node();
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int key) {
        if (cache.find(key) == cache.end()) {
            return -1;
        }
        Node* node = cache[key];
        moveToHead(node);
        return node->value;
    }
    
    void put(int key, int value) {
        if (cache.find(key) != cache.end()) {
            Node* node = cache[key];
            node->value = value;
            moveToHead(node);
        } else {
            Node* node = new Node(key, value);
            cache[key] = node;
            addToHead(node);
            
            if (cache.size() > capacity) {
                Node* removed = removeTail();
                cache.erase(removed->key);
                delete removed;
            }
        }
    }
    
    ~LRUCache() {
        Node* curr = head;
        while (curr) {
            Node* next = curr->next;
            delete curr;
            curr = next;
        }
    }
};</code></pre>
            </div>

            <div id="java" class="code-container">
                <pre><code class="language-java">import java.util.*;

class Node {
    int key, value;
    Node prev, next;
    
    Node(int key, int value) {
        this.key = key;
        this.value = value;
    }
}

class LRUCache {
    private int capacity;
    private Map<Integer, Node> cache;
    private Node head, tail;
    
    /**
     * HashMap + 雙向鏈表
     * 時間複雜度: O(1)
     * 空間複雜度: O(capacity)
     */
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap<>();
        
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        Node node = cache.get(key);
        moveToHead(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        if (cache.containsKey(key)) {
            Node node = cache.get(key);
            node.value = value;
            moveToHead(node);
        } else {
            Node node = new Node(key, value);
            cache.put(key, node);
            addToHead(node);
            
            if (cache.size() > capacity) {
                Node removed = removeTail();
                cache.remove(removed.key);
            }
        }
    }
    
    private void addToHead(Node node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }
    
    private void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    
    private void moveToHead(Node node) {
        removeNode(node);
        addToHead(node);
    }
    
    private Node removeTail() {
        Node node = tail.prev;
        removeNode(node);
        return node;
    }
}</code></pre>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">複雜度分析</h2>
            <div class="complexity-box">
                <div class="complexity-item">時間複雜度: O(1)</div>
                <p style="color: #78716c; margin: 10px 0;">
                    get 和 put 操作都是 O(1)。<br>
                    HashMap 查找 O(1)，雙向鏈表操作 O(1)。
                </p>
                
                <div class="complexity-item" style="margin-top: 20px;">空間複雜度: O(capacity)</div>
                <p style="color: #78716c; margin: 10px 0;">
                    HashMap 和鏈表最多存儲 capacity 個節點。
                </p>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">重點提示</h2>
            <div class="complexity-box">
                <ul>
                    <li><strong>設計題關鍵：</strong>選擇合適的資料結構組合</li>
                    <li><strong>HashMap + 雙向鏈表：</strong>完美搭配
                        <ul style="margin-top: 8px;">
                            <li>HashMap：O(1) 查找</li>
                            <li>雙向鏈表：O(1) 插入/刪除/移動</li>
                        </ul>
                    </li>
                    <li><strong>哨兵節點：</strong>簡化邊界處理，無需特判頭尾</li>
                    <li><strong>鏈表順序：</strong>
                        <ul style="margin-top: 8px;">
                            <li>頭部 = 最近使用（MRU）</li>
                            <li>尾部 = 最久未用（LRU）</li>
                        </ul>
                    </li>
                    <li><strong>常見錯誤：</strong>
                        <ul style="margin-top: 8px;">
                            <li>只用 HashMap 或只用鏈表（無法 O(1)）</li>
                            <li>忘記更新 HashMap 中的引用</li>
                            <li>鏈表操作指標錯誤</li>
                            <li>get 後忘記移動節點到頭部</li>
                        </ul>
                    </li>
                    <li><strong>面試技巧：</strong>
                        <ul style="margin-top: 8px;">
                            <li>先說明為什麼需要兩種資料結構</li>
                            <li>畫圖展示鏈表操作</li>
                            <li>說明哨兵節點的作用</li>
                            <li>討論時間複雜度為什麼是 O(1)</li>
                        </ul>
                    </li>
                    <li><strong>變形題：</strong>LFU Cache (#460) - 最少使用頻率</li>
                    <li><strong>相似題目：</strong>Design HashMap (706), Design LinkedList (707)</li>
                    <li><strong>公司頻率：</strong>Amazon ⭐⭐⭐⭐⭐, Microsoft ⭐⭐⭐⭐⭐, Google ⭐⭐⭐⭐⭐</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        hljs.highlightAll();
        
        function showLanguage(lang) {
            document.querySelectorAll('.code-container').forEach(container => {
                container.classList.remove('active');
            });
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(lang).classList.add('active');
            event.target.classList.add('active');
        }
    </script>
</body>
</html>