<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>84. Largest Rectangle in Histogram - LeetCode 學習平台</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8fafc; line-height: 1.8; color: #334155; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%); color: white; padding: 40px; border-radius: 16px; margin-bottom: 30px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .back-btn { display: inline-block; color: white; text-decoration: none; background: rgba(255,255,255,0.2); padding: 10px 20px; border-radius: 8px; margin-bottom: 20px; transition: all 0.3s; }
        .back-btn:hover { background: rgba(255,255,255,0.3); }
        .problem-title { font-size: 2.5em; font-weight: 800; margin-bottom: 15px; }
        .difficulty { display: inline-block; background: rgba(255,255,255,0.3); padding: 8px 20px; border-radius: 20px; font-weight: 600; font-size: 0.9em; }
        .content-section { background: white; padding: 40px; border-radius: 16px; margin-bottom: 25px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .section-title { font-size: 1.8em; color: #1e293b; margin-bottom: 25px; font-weight: 700; padding-bottom: 10px; border-bottom: 3px solid #dc2626; }
        .description { font-size: 1.1em; line-height: 1.9; color: #475569; margin-bottom: 20px; }
        .example-box { background: #fee2e2; border-left: 4px solid #dc2626; padding: 20px; border-radius: 8px; margin: 20px 0; }
        .example-title { font-weight: 700; color: #991b1b; margin-bottom: 10px; font-size: 1.1em; }
        .approach-box { background: #eff6ff; border-left: 4px solid #3b82f6; padding: 25px; border-radius: 8px; margin: 25px 0; }
        .approach-title { font-weight: 700; color: #1e40af; margin-bottom: 15px; font-size: 1.3em; }
        .complexity-box { background: #fef3c7; border-left: 4px solid #f59e0b; padding: 20px; border-radius: 8px; margin: 20px 0; }
        .complexity-item { margin: 10px 0; font-weight: 600; color: #92400e; }
        .language-tabs { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        .tab-btn { padding: 12px 28px; border: 2px solid #dc2626; background: white; color: #dc2626; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s; font-size: 1em; }
        .tab-btn:hover { background: #fee2e2; }
        .tab-btn.active { background: #dc2626; color: white; }
        .code-container { display: none; margin-top: 20px; }
        .code-container.active { display: block; }
        pre { background: #282c34 !important; padding: 25px !important; border-radius: 12px; overflow-x: auto; margin: 0; }
        code { font-family: 'Fira Code', 'Consolas', monospace; font-size: 0.95em; line-height: 1.6; }
        ol, ul { margin-left: 30px; margin-top: 15px; }
        li { margin: 12px 0; line-height: 1.8; }
        strong { color: #1e293b; font-weight: 700; }
        .visual-box { background: #f0f9ff; border: 2px solid #3b82f6; padding: 20px; border-radius: 8px; margin: 20px 0; }
        
        @media (max-width: 768px) {
            .container { padding: 10px; }
            .header { padding: 25px; }
            .problem-title { font-size: 1.8em; }
            .content-section { padding: 25px; }
            .tab-btn { padding: 10px 20px; font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="../index.html" class="back-btn">← 返回題目列表</a>
            <div class="problem-title">84. Largest Rectangle in Histogram</div>
            <span class="difficulty">Hard</span>
        </div>

        <div class="content-section">
            <h2 class="section-title">題目描述</h2>
            <div class="description">
                <p>給定 <code>n</code> 個非負整數，用來表示柱狀圖中各個柱子的高度。每個柱子彼此相鄰，且寬度為 <code>1</code>。</p>
                <p style="margin-top: 15px;">求在該柱狀圖中，能夠勾勒出來的矩形的最大面積。</p>
            </div>

            <div class="example-box">
                <div class="example-title">範例 1:</div>
                <pre><code>輸入: heights = [2,1,5,6,2,3]
輸出: 10
解釋: 最大的矩形為圖中紅色區域，面積為 10</code></pre>
                <div style="margin-top: 10px; text-align: center;">
                    <svg width="300" height="180" style="background: white; border-radius: 8px; padding: 10px;">
                        <!-- 柱狀圖 -->
                        <rect x="20" y="140" width="40" height="20" fill="#93c5fd" stroke="#3b82f6"/>
                        <rect x="70" y="150" width="40" height="10" fill="#93c5fd" stroke="#3b82f6"/>
                        <rect x="120" y="110" width="40" height="50" fill="#fca5a5" stroke="#dc2626"/>
                        <rect x="170" y="100" width="40" height="60" fill="#fca5a5" stroke="#dc2626"/>
                        <rect x="220" y="140" width="40" height="20" fill="#93c5fd" stroke="#3b82f6"/>
                        <rect x="270" y="130" width="40" height="30" fill="#93c5fd" stroke="#3b82f6"/>
                        
                        <!-- 標示 -->
                        <text x="40" y="175" font-size="12" text-anchor="middle">2</text>
                        <text x="90" y="175" font-size="12" text-anchor="middle">1</text>
                        <text x="140" y="175" font-size="12" text-anchor="middle">5</text>
                        <text x="190" y="175" font-size="12" text-anchor="middle">6</text>
                        <text x="240" y="175" font-size="12" text-anchor="middle">2</text>
                        <text x="290" y="175" font-size="12" text-anchor="middle">3</text>
                        
                        <text x="180" y="85" font-size="14" fill="#dc2626" font-weight="bold">面積 = 5 × 2 = 10</text>
                    </svg>
                </div>
            </div>

            <div class="example-box">
                <div class="example-title">範例 2:</div>
                <pre><code>輸入: heights = [2,4]
輸出: 4</code></pre>
            </div>

            <div class="example-box">
                <div class="example-title">限制條件:</div>
                <pre><code>1 <= heights.length <= 10^5
0 <= heights[i] <= 10^4</code></pre>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">解題思路</h2>
            
            <div class="approach-box">
                <div class="approach-title">核心觀察</div>
                <p>這是一個經典的<strong>單調棧</strong>問題：</p>
                <ul>
                    <li>對於每個柱子，需要找到左右兩邊第一個比它矮的柱子</li>
                    <li>矩形寬度 = 右邊界 - 左邊界 - 1</li>
                    <li>矩形高度 = 當前柱子高度</li>
                    <li>面積 = 高度 × 寬度</li>
                </ul>
                <p style="margin-top: 15px; color: #dc2626; font-weight: 600;">
                    關鍵：使用單調遞增棧，遇到更矮的柱子時計算面積
                </p>
            </div>
            
            <div class="approach-box">
                <div class="approach-title">方法一：單調棧（推薦）⭐⭐⭐</div>
                <p>使用單調遞增棧來高效找到每個柱子的左右邊界。</p>
                
                <p style="margin-top: 15px;"><strong>核心思想：</strong></p>
                <p>維護一個單調遞增的棧（存儲索引）：</p>
                <ul>
                    <li>當前柱子 >= 棧頂柱子 → 入棧</li>
                    <li>當前柱子 < 棧頂柱子 → 彈出棧頂並計算面積</li>
                    <li>彈出的柱子高度作為矩形高度</li>
                    <li>左邊界 = 新棧頂，右邊界 = 當前位置</li>
                </ul>
                
                <p style="margin-top: 15px;"><strong>步驟：</strong></p>
                <ol>
                    <li>創建單調遞增棧（存儲索引）</li>
                    <li>遍歷每個柱子：
                        <ul>
                            <li>當棧不空且當前柱子 < 棧頂柱子：
                                <ul>
                                    <li>彈出棧頂索引 top</li>
                                    <li>高度 = heights[top]</li>
                                    <li>寬度 = i - stack[-1] - 1（如果棧空則為 i）</li>
                                    <li>面積 = 高度 × 寬度</li>
                                    <li>更新最大面積</li>
                                </ul>
                            </li>
                            <li>將當前索引入棧</li>
                        </ul>
                    </li>
                    <li>處理棧中剩餘元素（右邊界為 n）</li>
                </ol>
                
                <div class="visual-box">
                    <p><strong>視覺化範例：heights = [2,1,5,6,2,3]</strong></p>
                    <pre style="background: white; padding: 15px; border-radius: 5px; margin-top: 10px;"><code>索引: 0  1  2  3  4  5
高度: 2  1  5  6  2  3

i=0: heights[0]=2
     棧為空，入棧
     stack = [0]

i=1: heights[1]=1
     1 < 2，彈出 0
     高度 = 2, 寬度 = 1（棧空，寬度為 i=1）
     面積 = 2 × 1 = 2
     入棧 1
     stack = [1]

i=2: heights[2]=5
     5 > 1，入棧
     stack = [1, 2]

i=3: heights[3]=6
     6 > 5，入棧
     stack = [1, 2, 3]

i=4: heights[4]=2
     2 < 6，彈出 3
     高度 = 6, 寬度 = 4-2-1 = 1
     面積 = 6 × 1 = 6
     
     2 < 5，彈出 2
     高度 = 5, 寬度 = 4-1-1 = 2
     面積 = 5 × 2 = 10 ✓ 最大！
     
     2 > 1，入棧
     stack = [1, 4]

i=5: heights[5]=3
     3 > 2，入棧
     stack = [1, 4, 5]

處理剩餘元素:
     彈出 5: 高度=3, 寬度=6-4-1=1, 面積=3
     彈出 4: 高度=2, 寬度=6-1-1=4, 面積=8
     彈出 1: 高度=1, 寬度=6, 面積=6

最大面積: 10</code></pre>
                </div>
            </div>

            <div class="approach-box">
                <div class="approach-title">方法二：優化的單調棧（哨兵技巧）</div>
                <p>在陣列首尾添加高度為 0 的哨兵，簡化邊界處理。</p>
                <ul style="margin-top: 10px;">
                    <li>前哨兵：確保所有元素都會入棧</li>
                    <li>後哨兵：確保所有元素都會彈出</li>
                    <li>代碼更簡潔</li>
                </ul>
            </div>

            <div class="approach-box">
                <div class="approach-title">方法三：暴力法（不推薦）</div>
                <p>對每個柱子，向左右擴展找邊界。</p>
                <p style="color: #64748b; margin-top: 10px;">
                    時間複雜度 O(n²)，會超時。
                </p>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">程式碼實現</h2>
            
            <div class="language-tabs">
                <button class="tab-btn active" onclick="showLanguage('python')">Python</button>
                <button class="tab-btn" onclick="showLanguage('cpp')">C++</button>
                <button class="tab-btn" onclick="showLanguage('java')">Java</button>
            </div>

            <div id="python" class="code-container active">
                <pre><code class="language-python">class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        """
        方法一：單調棧
        時間複雜度: O(n)
        空間複雜度: O(n)
        """
        stack = []  # 單調遞增棧（存儲索引）
        max_area = 0
        
        for i, h in enumerate(heights):
            # 當前柱子比棧頂矮，彈出並計算面積
            while stack and heights[stack[-1]] > h:
                height = heights[stack.pop()]
                # 寬度計算：當前位置 - 左邊界 - 1
                width = i if not stack else i - stack[-1] - 1
                max_area = max(max_area, height * width)
            
            stack.append(i)
        
        # 處理棧中剩餘元素
        while stack:
            height = heights[stack.pop()]
            width = len(heights) if not stack else len(heights) - stack[-1] - 1
            max_area = max(max_area, height * width)
        
        return max_area
    
    def largestRectangleArea_sentinel(self, heights: List[int]) -> int:
        """
        方法二：哨兵優化版本
        時間複雜度: O(n)
        空間複雜度: O(n)
        """
        # 添加前後哨兵
        heights = [0] + heights + [0]
        stack = [0]  # 前哨兵索引
        max_area = 0
        
        for i in range(1, len(heights)):
            # 遇到更矮的柱子，彈出並計算
            while heights[stack[-1]] > heights[i]:
                h = heights[stack.pop()]
                w = i - stack[-1] - 1
                max_area = max(max_area, h * w)
            
            stack.append(i)
        
        return max_area
    
    def largestRectangleArea_optimized(self, heights: List[int]) -> int:
        """
        方法三：最簡潔版本
        """
        heights.append(0)  # 後哨兵
        stack = [-1]  # 前哨兵
        max_area = 0
        
        for i in range(len(heights)):
            while stack[-1] != -1 and heights[stack[-1]] > heights[i]:
                h = heights[stack.pop()]
                w = i - stack[-1] - 1
                max_area = max(max_area, h * w)
            stack.append(i)
        
        return max_area</code></pre>
            </div>

            <div id="cpp" class="code-container">
                <pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
using namespace std;

class Solution {
public:
    /**
     * 方法一：單調棧
     * 時間複雜度: O(n)
     * 空間複雜度: O(n)
     */
    int largestRectangleArea(vector<int>& heights) {
        stack<int> st;
        int maxArea = 0;
        int n = heights.size();
        
        for (int i = 0; i < n; i++) {
            while (!st.empty() && heights[st.top()] > heights[i]) {
                int h = heights[st.top()];
                st.pop();
                int w = st.empty() ? i : i - st.top() - 1;
                maxArea = max(maxArea, h * w);
            }
            st.push(i);
        }
        
        // 處理剩餘元素
        while (!st.empty()) {
            int h = heights[st.top()];
            st.pop();
            int w = st.empty() ? n : n - st.top() - 1;
            maxArea = max(maxArea, h * w);
        }
        
        return maxArea;
    }
    
    /**
     * 方法二：哨兵優化
     */
    int largestRectangleArea_sentinel(vector<int>& heights) {
        heights.insert(heights.begin(), 0);
        heights.push_back(0);
        
        stack<int> st;
        st.push(0);
        int maxArea = 0;
        
        for (int i = 1; i < heights.size(); i++) {
            while (heights[st.top()] > heights[i]) {
                int h = heights[st.top()];
                st.pop();
                int w = i - st.top() - 1;
                maxArea = max(maxArea, h * w);
            }
            st.push(i);
        }
        
        return maxArea;
    }
};</code></pre>
            </div>

            <div id="java" class="code-container">
                <pre><code class="language-java">import java.util.Stack;

class Solution {
    /**
     * 方法一：單調棧
     * 時間複雜度: O(n)
     * 空間複雜度: O(n)
     */
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> stack = new Stack<>();
        int maxArea = 0;
        int n = heights.length;
        
        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && heights[stack.peek()] > heights[i]) {
                int h = heights[stack.pop()];
                int w = stack.isEmpty() ? i : i - stack.peek() - 1;
                maxArea = Math.max(maxArea, h * w);
            }
            stack.push(i);
        }
        
        // 處理剩餘元素
        while (!stack.isEmpty()) {
            int h = heights[stack.pop()];
            int w = stack.isEmpty() ? n : n - stack.peek() - 1;
            maxArea = Math.max(maxArea, h * w);
        }
        
        return maxArea;
    }
    
    /**
     * 方法二：哨兵優化
     */
    public int largestRectangleArea_sentinel(int[] heights) {
        int n = heights.length;
        int[] newHeights = new int[n + 2];
        newHeights[0] = 0;
        newHeights[n + 1] = 0;
        System.arraycopy(heights, 0, newHeights, 1, n);
        
        Stack<Integer> stack = new Stack<>();
        stack.push(0);
        int maxArea = 0;
        
        for (int i = 1; i < newHeights.length; i++) {
            while (newHeights[stack.peek()] > newHeights[i]) {
                int h = newHeights[stack.pop()];
                int w = i - stack.peek() - 1;
                maxArea = Math.max(maxArea, h * w);
            }
            stack.push(i);
        }
        
        return maxArea;
    }
}</code></pre>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">複雜度分析</h2>
            <div class="complexity-box">
                <div class="complexity-item">時間複雜度: O(n)</div>
                <p style="color: #78716c; margin: 10px 0;">
                    每個柱子最多入棧一次、出棧一次，總共 O(2n) = O(n)。
                </p>
                
                <div class="complexity-item" style="margin-top: 20px;">空間複雜度: O(n)</div>
                <p style="color: #78716c; margin: 10px 0;">
                    棧最多存儲 n 個索引。
                </p>
            </div>
        </div>

        <div class="content-section">
            <h2 class="section-title">重點提示</h2>
            <div class="complexity-box">
                <ul>
                    <li><strong>單調棧核心：</strong>高效找到每個元素左右兩邊第一個更小/更大的元素</li>
                    <li><strong>為什麼用單調遞增棧？</strong>
                        <ul style="margin-top: 8px;">
                            <li>遇到更矮的柱子時，可以確定之前較高柱子的右邊界</li>
                            <li>棧頂始終是當前可能的左邊界</li>
                            <li>彈出時可以同時獲得左右邊界信息</li>
                        </ul>
                    </li>
                    <li><strong>寬度計算技巧：</strong>
                        <ul style="margin-top: 8px;">
                            <li>右邊界：當前索引 i</li>
                            <li>左邊界：彈出後的新棧頂</li>
                            <li>寬度 = i - stack[-1] - 1</li>
                            <li>如果棧空，寬度 = i（從開始到 i）</li>
                        </ul>
                    </li>
                    <li><strong>哨兵技巧：</strong>
                        <ul style="margin-top: 8px;">
                            <li>前哨兵（高度0）：確保第一個元素能入棧</li>
                            <li>後哨兵（高度0）：確保所有元素都會彈出</li>
                            <li>簡化邊界判斷，代碼更簡潔</li>
                        </ul>
                    </li>
                    <li><strong>單調棧模板：</strong>
                        <ul style="margin-top: 8px;">
                            <li>遍歷元素</li>
                            <li>while 棧不空 且 不滿足單調性：彈出並處理</li>
                            <li>將當前元素入棧</li>
                            <li>處理棧中剩餘元素</li>
                        </ul>
                    </li>
                    <li><strong>邊界情況：</strong>
                        <ul style="margin-top: 8px;">
                            <li>只有一個柱子 → 返回其高度</li>
                            <li>所有柱子等高 → 高度 × 柱子數</li>
                            <li>遞增序列 → 最後處理剩餘元素</li>
                            <li>遞減序列 → 逐個彈出計算</li>
                            <li>包含 0 的柱子</li>
                        </ul>
                    </li>
                    <li><strong>常見錯誤：</strong>
                        <ul style="margin-top: 8px;">
                            <li>寬度計算公式錯誤</li>
                            <li>忘記處理棧中剩餘元素</li>
                            <li>棧空時的邊界判斷錯誤</li>
                            <li>索引和高度混淆</li>
                        </ul>
                    </li>
                    <li><strong>面試技巧：</strong>
                        <ul style="margin-top: 8px;">
                            <li>先畫柱狀圖示意</li>
                            <li>說明單調棧的作用</li>
                            <li>展示棧的變化過程</li>
                            <li>強調 O(n) 時間複雜度</li>
                            <li>可以提到哨兵優化</li>
                        </ul>
                    </li>
                    <li><strong>單調棧應用場景：</strong>
                        <ul style="margin-top: 8px;">
                            <li>找下一個更大/更小元素</li>
                            <li>找左右邊界</li>
                            <li>直方圖相關問題</li>
                            <li>股票價格問題</li>
                        </ul>
                    </li>
                    <li><strong>延伸思考：</strong>
                        <ul style="margin-top: 8px;">
                            <li>如果柱子有不同寬度？</li>
                            <li>如何找到實際的矩形位置？</li>
                            <li>如何處理負數高度？（不合理）</li>
                        </ul>
                    </li>
                    <li><strong>變形題：</strong>
                        <ul style="margin-top: 8px;">
                            <li>Maximal Rectangle (#85) - 二維版本</li>
                            <li>Trapping Rain Water (#42) - 接雨水</li>
                            <li>Daily Temperatures (#739) - 溫度</li>
                            <li>Next Greater Element (#496, #503)</li>
                        </ul>
                    </li>
                    <li><strong>實際應用：</strong>圖像處理、視覺分析、數據可視化</li>
                    <li><strong>相似題目：</strong>Trapping Rain Water (42), Maximal Rectangle (85)</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        hljs.highlightAll();
        
        function showLanguage(lang) {
            document.querySelectorAll('.code-container').forEach(container => {
                container.classList.remove('active');
            });
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(lang).classList.add('active');
            event.target.classList.add('active');
        }
    </script>
</body>
</html>